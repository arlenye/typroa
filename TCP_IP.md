## TCP_IP

当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当做一串比特流送入网络，其中每一层对收到的数据都要增加一些首部信息。

当主机收到一个以太网数据帧时，数据就开始从协议栈中有底向上升，同时去掉各层协议上的报文首部。每层协议都要检查报文首部中的协议标志，以确定接收数据的上层协议。

### 1.tcp/ip的三次握手和四次挥手是什么概念，以及状态变化过程？

#### 三次握手

A                           B

syn-send         syn-rcvd

established    established



1. A----syn reqest   
2. B-----syn + ack
3. A------ack

#### 4次挥手

A                           B

FIN_WAIT_1         CLOSE_WAIT

FIN_WAIT_2         ALST_ACK

FIN_WAIT_3         



1. A----FIN
2. B----ACK
3. B----FIN
4. A-----ACK

### 2.建立连接需要3次，为什么断开连接需要4次？

三次握手是因为因为当 Server 端收到 Client 端的 SYN -req连 接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK报文是用来应答的， SYN 报文是用来同步的。但是关闭连 接时，当 Server 端收到 FIN 报文时，很可能并不会立即 关闭 SOCKET （ 因 为 可 能 还 有 消 息 没 处 理 完 ）， 所 以 只 能 先回复一个 ACK 报文，告诉 Client 端， " 你发的 FIN 报文 我收到了 " 。只有等到我 Se rver 端所有的报文都发送完 了，我才能发送 FIN 报文，因此不能一起发送。故需要四 步握手。 

3.三次握手有哪些不安全性？



### 4.TCP和UDP的区别？TCP是通过什么方式来保证可靠性的

T C P和U D P是两种最为著名的传输层协议，他们都是 使用I P作为网络层协议。

IP协议提供了一组数据报文服 务，每组分组报文都是由网络独立处理和分发，就像寄送 快递包裹一样，为了实现这个功能，每个IP报文必须包 含一个目的地址的字段；就像我们寄送快递都需要写明收 件人信息，但是和我们寄送快递一样，也可能会出现包裹 丢失问题，所以IP协议只是一个“尽力而为”的协议，在网 络传输过程中，可能会发生报文丢失、报文顺序打乱，重 复发送的情况。IP协议层之上的传输层，提供了两种可以 选择的协议，TCP、UPD。这两种协议都是建立在IP层所 提供的服务基础上，根据应用程序的不同需求选择不同方 式的传输； 

TCP/IP 
TCP协议能够检测和恢复IP层提供的主机到主机的通信 中可能发生的报文丢失、重复及其他错误。TCP 提供了一 个可信赖的字节流通道，这样应用程序就不需要考虑这些 问题。同时，TCP协议是一种面向连接的协议，在使用TCP 进行通信之前，两个应用程序之间需要建立一个TCP连接， 而这个连接又涉及到两台电脑需要完成握手消息的交换。 

UDP/IP 
UDP协议不会对IP层产生的错误进行修复，而是简单的 扩展了 IP 协议“尽力而为”的数据报文服务，使他能够在应 用程序之间工作，而不是在主机之间工作，因此使用UDP 协议必须要考虑到报文丢失，顺序混乱的问题 

多播：消息只发送给一个多播地址，网络只是将数据分发 给哪些想要接收发送到该多播地址的数据的主机。 总的来说，要实现这个功能，只有UDP是最合适的 



### TCP 是如何做到可靠传输的？ 

建立可靠的链接 
由于TCP协议是一种可信的传输协议，所以在传输之 前，需要通过三次握手建立一个连接，所谓的三次握手， 就是在建立TCP链接时，需要客户端和服务端总共发送3 个包来确认连接的建立 。

TCP 四次挥手协议 
四次挥手表示 TCP 断开连接的时候,需要客户端和服务端 总共发送 4 个包以确认连接的断开；客户端或服务器均可 主动发起挥手动作(因为 TCP 是一个全双工协议)，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 

建立可靠连接以后，就开始进行数据传输了。在通信过程 中，最重要的是数据包，也就是协议传输的数据。如果数 据的传送与接收过程当中出现收方来不及接收的情况，这 时就需要对发方进行控制以免数据丢失。利用滑动窗口机 制可以很方便的在TCP连接上实现对发送方的流量控 制。TCP的窗口单位是字节，不是报文段，发送方的发送 窗口不能超过接收方给出的接收窗口的数值。 

对于 TCP 通信来说，每个 TCP Socket 的内核中都有一个 发送缓冲区和一个接收缓冲区，TCP 的全双工的工作模式 及 TCP 的滑动窗口就是依赖于这两个独立的 Buffer 和该 Buffer的填充状态。  接收缓冲区把数据缓存到内核，若应用进程一直没有调用 Socket 的 read 方法进行读取，那么该数据会一直被缓存 在接收缓冲区内。不管进程是否读取Socket，对端发来的 数据都会经过内核接收并缓存到 Socket 的内核接收缓冲 区。

 read所要做的工作，就是把内核接收缓冲区中的数据复制 到应用层用户的Buffer里。 进程调用Socket的send发送数据的时候，一般情况下是 将数据从应用层用户的 Buffer 里复制到 Socket 的内核发 送缓冲区，然后send就会在上层返回。换句话说，send返 回时，数据不一定会被发送到对端。 

Socket 的接收缓冲区被 TCP 用来缓存网络上收到的数据， 一直保存到应用进程读走为止。如果应用进程一直没有读 取，那么Buffer满了以后，出现的情况是：通知对端TCP 协议中的窗口关闭，保证TCP接收缓冲区不会移除，保证 了TCP是可靠传输的。如果对方无视窗口大小发出了超过 窗口大小的数据，那么接收方会把这些数据丢弃。 

### 5.tcp四层网络模型和osi七层网络模型分别是什么？以及每一层的作用

应用层 

表示层

会话层                          应用层          与用户交互 HTTP请求报文

传输层                          传输层          TCP头   相当于为包裹选了个快递公司

网络层                          网络层           IP头  相当于填写这个包裹要送到那个地方（门牌号）

数据链路层                   数据链路层  Mac头 相当于填写要寄给那个具体的人（全局唯一）

物理层                           物理层           转换为比特流进行传输

### 6.什么是滑动窗口协议？它的实现原理是什么？

滑动窗口（Sliding window）是一种流量控制技术。早期的 网络通信中，通信双方不会考虑网络的拥挤情况直接发送 数据。由于大家不知道网络拥塞状况，同时发送数据，导 致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题；发送和接受方都会维护一个数据 帧的序列，这个序列被称作窗口 

简单解释下，发送和接受方都会维护一个数据帧的序列， 这个序列被称作窗口。发送方的窗口大小由接受方确定， 目的在于控制发送速度，以免接受方的缓存不够大，而导 致溢出，同时控制流量也可以避免网络拥塞。下面图中的 4,5,6 号数据帧已经被发送出去，但是 未收到关联的 ACK ， 7,8,9 帧则是等待发送。可以看出发送端的窗口大 小为 6 ，这是由接受端告知的。此时如果发送端收到 4 号 ACK ，则窗口的左边缘向右收缩，窗口的右边缘则向右扩 展，此时窗口就向前 “ 滑动了 ” ，即数据帧 10 也可以被发 送。 
发送窗口 
就是发送端允许连续发送的幀的序号表。 发送端可以不等待应答而连续发送的最大幀数称为发送窗 口的尺寸

接收窗口 
接收方允许接收的幀的序号表，凡落在 接收窗口内的幀， 接收方都必须处理，落在接收窗口外的幀被丢弃。 

### 7.服务器上TIME_WAIT状态的连接过多，怎么解决？

多线程

使用非阻塞

### 8.什么是NIO、BIO、AIO？他们的区别？

BIO

我们发现TCP响应服务器一次只能处理一个客户端请 求，当一个客户端向一个已经被其他客户端占用的服务器 发送连接请求时，虽然在连接建立后可以向服务端发送数 据，但是在服务端处理完之前的请求之前，却不会对新的 客户端做出响应，这种类型的服务器称为“迭代服务器”。 迭代服务器是按照顺序处理客户端请求，也就是服务端必 须要处理完前一个请求才能对下一个客户端的请求进行响 应。但是在实际应用中，我们不能接收这样的处理方式。 所以我们需要一种方法可以独立处理每一个连接，并且他 们之间不会相互干扰。

NIO

非阻塞要解决的就是I/O线程与Socket解耦的问题，因 此，它引入了事件机制来达到解耦的目的。我们可以认为 NIO底层中存在一个I/O调度线程，它不断的扫描每个 Socket的缓冲区，当发现写入缓冲区为空的时候，它会 产生一个Socket可写事件，此时程序就可以把数据写入 到Socket中。如果一次写不完，就等待下一次的可写事 件通知；反之，当发现缓冲区里有数据的时候，它会产生 一个Socket可读事件，程序收到这个通知事件就可以从 Socket读取数据了。 

实际上基于上面讲的传统的BIO模型，一个请求一个线程 的方式，如果要涉及到上千个客户端访问时，会产生很多 的问题，比如扩展性、系统资源开销等等。所以我们需要 一种方法来轮询一组客户端，来查找哪个连接需要提供服 务，这个就是我们讲的“NIO”； 

- [Java ](http://lib.csdn.net/base/java)BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

- Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

  Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理， 

### 9.了解过多路复用吗？它是一个什么实现原理？

缓冲区 
在NIO中，所有数据都是用缓冲区处理，在读取数据的时 候，它是直接读到缓冲区中，在写如数据的时候，也是写 到缓冲区。任何时候访问NIO中的数据，都是通过缓冲区 进行的操作 
通道 
Channel 通道，就像一个自来水管一样，可以通过它读取 和写入数据，Channel是全双工的，所以数据是双向流动。

多路复用 
多路复用器Selector，是NIO的基础，多路复用器提供选 择已经就绪的任务的能力，简单来说，Selector 会不断轮 询注册上的Channel，如果某个Channel上面有新的TCP 连接接入、读、写事件，这个 Channel 就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取 就绪的Channel进行I/O操作；一个多路复用器可以同时 轮询多个 Channel。通过这个机制可以接入成千上万的客 户端。 

### 10.epool和select的区别是什么？



### 为什么有了MAC层还要走IP层呢？

mac地址就好像个人的身份证号，人的身份证号和人户口 所在的城市，出生的日期有关，但是和人所在的位置没有 关系，人是会移动的，知道一个人的身份证号，并不能找 到它这个人，mac地址类似，它是和设备的生产者，批 次，日期之类的关联起来，知道一个设备的mac，并不能 在网络中将数据发送给它，除非它和发送方的在同一个网 络内。所以要实现机器之间的通信，还需要有ip地址的 概念，ip地址表达的是当前机器在网络中的位置，类似于 城市名+道路号+门牌号的概念。通过ip层的寻址，我们 能知道按何种路径在全世界任意两台Internet上的的机器 间传输数据。 
重